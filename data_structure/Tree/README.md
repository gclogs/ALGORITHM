# 이진 트리(Binary Tree) 구현 비교 분석

이 프로젝트는 세 가지 다른 방식으로 이진 트리를 구현하고 그 특성을 비교 분석합니다.

## 목차
1. [이진 트리란?](#이진-트리란)
2. [구현 방식 비교](#구현-방식-비교)
3. [성능 분석](#성능-분석)
4. [사용 시나리오](#사용-시나리오)
5. [코드 예제](#코드-예제)

## 이진 트리란?

이진 트리는 각 노드가 최대 두 개의 자식을 가질 수 있는 트리 구조입니다.

### 주요 특징
- 각 노드는 왼쪽 자식과 오른쪽 자식을 가질 수 있음
- 데이터를 계층적으로 저장
- 검색, 삽입, 삭제 등의 연산을 효율적으로 수행

### 활용 예시
- 파일 시스템의 디렉토리 구조
- 검색 알고리즘
- 수식 계산기
- 데이터 압축

## 구현 방식 비교

### 1. 연결 리스트 방식 (Python)
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
```
- **장점**
  - 동적 메모리 할당이 자유로움
  - 노드 삽입/삭제가 빠름 (O(1))
  - 메모리 낭비가 적음

- **단점**
  - 임의 접근이 어려움
  - 추가 메모리 공간 필요 (포인터)
  - 캐시 지역성이 낮음

### 2. ArrayList 방식 (Java)
```java
ArrayList<Node<T>> nodes = new ArrayList<>();
```
- **장점**
  - 순차적 접근이 빠름
  - 캐시 지역성이 좋음
  - 구현이 직관적

- **단점**
  - 삽입/삭제 시 시간이 오래 걸림 (O(n))
  - 크기 조정 시 오버헤드
  - 메모리 낭비 가능성

### 3. HashMap 방식 (Java)
```java
HashMap<Integer, T> tree = new HashMap<>();
```
- **장점**
  - 노드 접근이 매우 빠름 (O(1))
  - 메모리 효율적
  - 희소 트리에 적합

- **단점**
  - 순차적 접근이 느림
  - 구현이 복잡
  - 해시 충돌 가능성

## 성능 분석

### 시간 복잡도 비교

| 연산 | 연결 리스트 | ArrayList | HashMap |
|------|------------|-----------|---------|
| 검색 | O(n) | O(1) | O(1) |
| 삽입 | O(1) | O(n) | O(1) |
| 삭제 | O(1) | O(n) | O(1) |
| 순회 | O(n) | O(n) | O(n) |

### 벤치마크 결과
- **실행 시간** (100회 반복, 크기 7의 트리)
  - ArrayList: 16,093 ns/operation
  - HashMap: 10,399 ns/operation

- **메모리 사용량**
  - ArrayList: 더 많은 메모리 사용
  - HashMap: 더 효율적인 메모리 사용

## 사용 시나리오

### 연결 리스트 방식 선택
- 잦은 삽입/삭제가 필요한 경우
- 메모리 제약이 있는 경우
- 동적 크기 조정이 중요한 경우

### ArrayList 방식 선택
- 빈번한 인덱스 접근이 필요한 경우
- 완전 이진 트리를 구현할 경우
- 구현의 단순성이 중요한 경우

### HashMap 방식 선택
- 빠른 검색이 필요한 경우
- 희소 트리를 다룰 경우
- 메모리 효율성이 중요한 경우

## 코드 예제

### 트리 생성
```java
// ArrayList 방식
Tree<Integer> arrayListTree = new Tree<>();
arrayListTree.makeTree(Arrays.asList(1, 2, 3, 4, 5));

// HashMap 방식
HashMapTree<Integer> hashMapTree = new HashMapTree<>();
hashMapTree.makeTree(Arrays.asList(1, 2, 3, 4, 5));
```

### 순회 예제
```java
// 레벨 순서 순회
List<Integer> levelOrder = tree.levelOrder();  // [1, 2, 3, 4, 5]

// 전위 순회
List<Integer> preOrder = tree.preOrder();      // [1, 2, 4, 5, 3]
```

## 결론

각 구현 방식은 고유한 장단점을 가지고 있으며, 사용 사례에 따라 적절한 방식을 선택하는 것이 중요합니다:

- **연결 리스트**: 동적인 변경이 많은 경우
- **ArrayList**: 순차적 접근이 많은 경우
- **HashMap**: 빠른 검색이 필요한 경우

실제 애플리케이션에서는 이러한 특성을 고려하여 가장 적합한 구현 방식을 선택해야 합니다.
