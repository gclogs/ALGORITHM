# 백준 1021번: 회전하는 큐

## 📝 문제 설명
회전하는 양방향 큐에서 원하는 원소를 뽑아내는데 필요한 최소 회전 횟수를 구하는 문제입니다.

### 가능한 연산
1. 첫 번째 원소를 뽑아낸다.
2. 왼쪽으로 한 칸 이동시킨다. (반시계 방향)
3. 오른쪽으로 한 칸 이동시킨다. (시계 방향)

## 💡 풀이 원리

### 1. 핵심 아이디어
- 목표 원소까지의 최단 거리를 찾는 것이 핵심
- 큐의 중간 지점을 기준으로 회전 방향 결정
  * 중간보다 앞: 왼쪽 회전이 유리
  * 중간보다 뒤: 오른쪽 회전이 유리

### 2. 회전 방향 결정 원리
```python
# 예시 큐: [1,2,3,4,5,6,7,8]
# 중간 지점: 4번 인덱스

case 1) 3을 찾을 때 (인덱스 2)
- 왼쪽으로 2칸 이동 (효율적) 
- 오른쪽으로 6칸 이동 (비효율적) 

case 2) 7을 찾을 때 (인덱스 6)
- 왼쪽으로 6칸 이동 (비효율적) 
- 오른쪽으로 2칸 이동 (효율적) 
```

### 3. 구현 방법
```python
# 1. 회전 방향 결정
if target_idx <= half_idx:  # 앞쪽에 있는 경우
    # 2. 왼쪽 회전 수행
    q.rotate(-target_idx)   # 음수: 왼쪽으로 target_idx만큼 회전
    cnt += target_idx       # 회전 횟수를 카운트에 추가
else:  # 뒤쪽에 있는 경우
    # 3. 오른쪽 회전 수행
    q.rotate(len(q)-target_idx)  # 양수: 오른쪽으로 (큐 길이 - target_idx)만큼 회전
    cnt += len(q)-target_idx     # 회전 횟수를 카운트에 추가

# 4. 목표 숫자 제거
q.popleft()  # 맨 앞에 위치한 목표 숫자를 제거
```

#### 코드 상세 설명

1. **회전 방향 결정** (`if target_idx <= half_idx`)
   - `target_idx`: 찾고자 하는 숫자의 현재 위치
   - `half_idx`: 현재 큐 크기의 절반 (`len(q)//2`)
   - 목표 위치가 중간보다 앞쪽이면 왼쪽 회전, 뒤쪽이면 오른쪽 회전 선택

2. **왼쪽 회전의 경우**
   - `q.rotate(-target_idx)`: 음수를 사용하여 왼쪽으로 회전
   - 예: `target_idx`가 2일 때, 왼쪽으로 2칸 회전
   - `cnt += target_idx`: 왼쪽으로 이동한 칸 수만큼 카운트 증가

3. **오른쪽 회전의 경우**
   - `q.rotate(len(q)-target_idx)`: 양수를 사용하여 오른쪽으로 회전
   - `len(q)-target_idx`: 뒤에서부터 목표까지의 거리
   - 예: 큐 길이가 8이고 `target_idx`가 6일 때, 오른쪽으로 2칸 회전
   - `cnt += len(q)-target_idx`: 오른쪽으로 이동한 칸 수만큼 카운트 증가

4. **목표 숫자 제거** (`q.popleft()`)
   - 회전이 완료되면 목표 숫자는 항상 맨 앞에 위치
   - `popleft()`로 맨 앞 원소를 제거
   - 이는 다음 목표의 정확한 위치 계산을 위해 필수

#### 예시
```python
# 초기 상태: q = [1,2,3,4,5], target = 3
target_idx = 2  # 3의 위치
half_idx = 5//2 = 2  # 중간 지점

# target_idx <= half_idx이므로 왼쪽 회전
q.rotate(-2)  # [1,2,3,4,5] -> [3,4,5,1,2]
cnt += 2      # 회전 횟수 2 추가
q.popleft()   # [3,4,5,1,2] -> [4,5,1,2]
```

### 4. 목표 숫자 제거의 중요성
- 각 목표 숫자를 찾은 후에는 반드시 제거해야 함
- 제거하지 않으면 다음 목표의 위치가 부정확해짐
- 예시:
  ```python
  # 제거하지 않는 경우 (잘못된 방법)
  [1,2,3,4] -> [2,3,4,1] -> [2,3,4,1] -> ...
  
  # 제거하는 경우 (올바른 방법)
  [1,2,3,4] -> [2,3,4,1] -> [3,4,1] -> [4,1,3]
  ```

## 특징
1. 동적 큐 크기
   - 원소를 뽑을 때마다 큐의 크기가 변함
   - 중간 지점도 동적으로 계산 필요 (`len(q)//2`)

2. 최적화 전략
   - 시계/반시계 방향 중 최소 회전 횟수 선택
   - 마치 시계의 시침을 최단 경로로 움직이는 것과 유사

3. collections.deque 활용
   - 양방향 큐 구현에 적합
   - O(1) 시간 복잡도로 양끝 연산 가능
   - `rotate()` 메서드로 효율적인 회전 구현

## 시간 복잡도
- `index()`: O(n)
- `rotate()`: O(k) (k는 회전 횟수)
- `popleft()`: O(1)
- 전체 시간 복잡도: O(mn) (m은 뽑아내려는 수의 개수)

## 입력 형식
```
첫째 줄: N M (큐의 크기, 뽑아내려는 수의 개수)
둘째 줄: M개의 수 (뽑아내려는 수들의 위치)
```

## 예시
```
입력:
10 3
2 9 5

출력:
8

실행 과정:
1. 2를 뽑기 위한 과정
   [1,2,3,4,5,6,7,8,9,10] -> [2,3,4,5,6,7,8,9,10,1]
   2 제거 후: [3,4,5,6,7,8,9,10,1]
   회전 횟수: 1회

2. 9를 뽑기 위한 과정
   [3,4,5,6,7,8,9,10,1] -> [9,10,1,3,4,5,6,7,8]
   9 제거 후: [10,1,3,4,5,6,7,8]
   회전 횟수: 3회

3. 5를 뽑기 위한 과정
   [10,1,3,4,5,6,7,8] -> [5,6,7,8,10,1,3,4]
   5 제거 후: [6,7,8,10,1,3,4]
   회전 횟수: 4회

총 회전 횟수: 1 + 3 + 4 = 8
```