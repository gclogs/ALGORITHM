# 덱(Deque) 구현 비교: collections.deque vs List 기반 구현

이 문서는 Python에서 덱을 구현하는 두 가지 방식의 차이점과 특징을 설명합니다.

## 1. List 기반 구현 (사용자 정의 Deque 클래스)

```python
class Deque:
    def __init__(self):
        self.items = []
```

### 특징
1. **구현 방식**
   - Python 리스트를 사용하여 직접 구현
   - `insert(0, item)`으로 앞쪽 삽입
   - `append(item)`으로 뒤쪽 삽입
   - `pop(0)`으로 앞쪽 제거
   - `pop()`으로 뒤쪽 제거

2. **시간 복잡도**
   - 앞쪽 삽입/삭제: O(n)
     - 리스트의 모든 요소를 한 칸씩 이동해야 함
   - 뒤쪽 삽입/삭제: O(1)
     - 리스트 끝에서 작업하므로 상수 시간
   - 조회(front/back): O(1)
   - 크기 확인: O(1)

3. **장단점**
   - 장점:
     - 구현이 직관적이고 이해하기 쉬움
     - 메모리 사용이 상대적으로 적음
   - 단점:
     - 앞쪽 삽입/삭제가 비효율적 (O(n))
     - 대용량 데이터 처리 시 성능 저하

## 2. collections.deque 사용

```python
from collections import deque
deque = deque()
```

### 특징
1. **구현 방식**
   - 이중 연결 리스트(doubly linked list) 기반
   - `appendleft(item)`으로 앞쪽 삽입
   - `append(item)`으로 뒤쪽 삽입
   - `popleft()`으로 앞쪽 제거
   - `pop()`으로 뒤쪽 제거

2. **시간 복잡도**
   - 앞쪽 삽입/삭제: O(1)
     - 포인터만 변경하면 되므로 상수 시간
   - 뒤쪽 삽입/삭제: O(1)
     - 포인터만 변경하면 되므로 상수 시간
   - 조회(front/back): O(1)
   - 크기 확인: O(1)

3. **장단점**
   - 장점:
     - 모든 기본 연산이 O(1)로 매우 효율적
     - 대용량 데이터 처리에 적합
     - Python 표준 라이브러리로 안정성 보장
   - 단점:
     - 메모리 사용이 상대적으로 많음
     - 내부 구현을 직접 이해/수정하기 어려움

## 성능 비교

| 연산 | List 기반 | collections.deque |
|------|-----------|------------------|
| push_front | O(n) | O(1) |
| push_back | O(1) | O(1) |
| pop_front | O(n) | O(1) |
| pop_back | O(1) | O(1) |
| front/back | O(1) | O(1) |
| size/empty | O(1) | O(1) |

## 사용 권장 사항

1. **collections.deque 사용 권장 상황**:
   - 대용량 데이터 처리가 필요한 경우
   - 앞쪽 삽입/삭제가 빈번한 경우
   - 성능이 중요한 경우
   - 양방향 데이터 처리가 필요한 경우

2. **List 기반 구현 사용 권장 상황**:
   - 교육 목적으로 자료구조를 이해하고 싶은 경우
   - 메모리 사용량이 중요한 경우
   - 뒤쪽 삽입/삭제만 주로 사용하는 경우
   - 커스텀 기능 구현이 필요한 경우

## 결론

백준 10866번 문제와 같이 성능이 중요한 알고리즘 문제에서는 `collections.deque`를 사용하는 것이 유리합니다. 특히 앞쪽 삽입/삭제 연산이 O(1)로 수행되어 시간 초과를 방지할 수 있습니다. 반면, 자료구조 학습이나 특별한 기능 구현이 필요한 경우에는 List 기반의 직접 구현이 더 적합할 수 있습니다.
