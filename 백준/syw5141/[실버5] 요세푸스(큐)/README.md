# [요세푸스 문제 풀이 설명](https://namu.wiki/w/%EC%9A%94%EC%84%B8%ED%91%B8%EC%8A%A4%20%EB%AC%B8%EC%A0%9C)

## 문제 설명
N명의 사람이 동그랗게 원을 만들어 앉아있습니다. 이제 순서대로 K번째 사람을 계속 제거합니다.
한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속 반복합니다.
이렇게 N명의 사람이 모두 제거될 때까지 진행하면서, 사람들이 제거되는 순서를 구하는 문제입니다.

예를 들어, 7명이 있고 3번째 사람을 제거한다면:
1. 처음에 1,2,3,4,5,6,7 순서로 앉아있음
2. 3번째 사람인 3이 제거됨
3. 남은 사람들: 1,2,4,5,6,7
4. 여기서 다시 3번째 사람인 6이 제거됨
5. 이런 식으로 계속 진행...

## 구현 방법

### 1. 기본 리스트 구현 (solve1)
- **시간 복잡도**: O(N²)
- **구현 방식**: 
  - 리스트의 `pop(0)`와 `append()`를 사용하여 큐를 회전
  - K-1번 회전 후 K번째 원소를 제거
- **단점**: 
  - `pop(0)`가 O(N) 시간이 소요되어 비효율적
  - 전체 시간 복잡도가 O(N²)으로 큰 N에 대해 느림

### 2. collections.deque 활용 (solve2)
- **시간 복잡도**: O(N)
- **구현 방식**:
  - `deque`의 `rotate()` 메서드를 사용하여 효율적으로 회전
  - `popleft()`로 O(1) 시간에 원소 제거
- **장점**:
  - 회전과 제거 연산이 모두 O(1)
  - 전체적으로 가장 효율적인 구현

### 3. 인덱스 계산 활용 (solve3)
- **시간 복잡도**: O(N)
- **구현 방식**:
  - 인덱스 계산으로 다음 제거할 위치를 결정
  - `(idx + K - 1) % len(arr)`로 다음 위치 계산
- **장점**:
  - 추가 라이브러리 없이 구현 가능
  - 직관적이고 이해하기 쉬운 코드

## Java 구현
Java에서는 `ArrayList`를 사용하여 solve3 방식으로 구현했습니다.
- **장점**:
  - 동적 크기 조절 가능
  - 요소 제거가 용이
- **특징**:
  - StringBuilder를 사용하여 문자열 연산 최적화
  - ArrayList의 remove() 메서드로 요소 제거

## 성능 비교
1. solve1: O(N²) - 가장 느림
2. solve2: O(N) - 가장 빠름
3. solve3: O(N) - solve2와 비슷한 성능

## 결론
- 큰 N값에 대해서는 deque를 사용한 solve2가 가장 효율적
- 코드 가독성과 이해도 면에서는 solve3가 우수
- Java 구현은 solve3 방식을 채택하여 ArrayList로 구현
