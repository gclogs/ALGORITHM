# 프린터 큐 (백준 1966번) 문제 설명
- [프린터 큐 Java로 이해하기](https://st-lab.tistory.com/201)

## 입력 형식 설명
```
3            # 테스트 케이스의 수

1 0          # [테스트 케이스 1] N=1(문서 개수), M=0(궁금한 문서의 위치)
5            # 문서의 중요도

4 2          # [테스트 케이스 2] N=4(문서 개수), M=2(궁금한 문서의 위치)
1 2 3 4      # 문서의 중요도

6 0          # [테스트 케이스 3] N=6(문서 개수), M=0(궁금한 문서의 위치)
1 1 9 1 1 1  # 문서의 중요도
```

## 테스트 케이스별 시뮬레이션

### 테스트 케이스 1
```
초기 상태: [🟨5]  (M=0인 문서를 🟨로 표시)
결과: 바로 출력 (1번째)
답: 1
```

### 테스트 케이스 2
초기 상태:
```
[1] [2] [🟨3] [4]  (M=2인 문서를 🟨로 표시)
```

프로세스:
1. ```[1] [2] [🟨3] [4]  -> 4가 가장 높음```
2. ```[2] [🟨3] [4] [1]  -> 4가 가장 높음```
3. ```[🟨3] [4] [1] [2]  -> 4가 가장 높음```
4. ```[4] [1] [2] [🟨3]  -> 4 출력 (1번째)```
5. ```[1] [2] [🟨3]      -> 3이 가장 높음```
6. ```[2] [🟨3] [1]      -> 3이 가장 높음```
7. ```[🟨3] [1] [2]      -> 3 출력 (2번째) ✨```

답: 2

### 테스트 케이스 3
초기 상태:
```
[🟨1] [1] [9] [1] [1] [1]  (M=0인 문서를 🟨로 표시)
```

프로세스:
1. ```[🟨1] [1] [9] [1] [1] [1]  -> 9가 가장 높음```
2. ```[1] [9] [1] [1] [1] [🟨1]  -> 9가 가장 높음```
3. ```[9] [1] [1] [1] [🟨1] [1]  -> 9 출력 (1번째)```
4. ```[1] [1] [1] [🟨1] [1]      -> 모든 중요도가 1로 동일```
5. ```[1] [1] [🟨1] [1] [1]      -> 순서대로 출력```
6. ```[1] [🟨1] [1] [1] [1]      -> 순서대로 출력```
7. ```[🟨1] [1] [1] [1]          -> 순서대로 출력```
8. ```[🟨1] [1] [1]              -> 출력 (5번째) ✨```

답: 5

## 문제 해결 포인트
1. 각 테스트 케이스마다:
   - 첫 줄: 문서의 개수(N)와 찾고자 하는 문서의 위치(M)
   - 둘째 줄: N개의 문서 중요도

2. 인쇄 규칙:
   - 현재 문서보다 중요도가 높은 문서가 있으면 현재 문서를 맨 뒤로 이동
   - 현재 문서가 가장 높은 중요도면 바로 출력
   - 중요도가 같은 경우 큐에 있는 순서대로 출력

3. 출력:
   - M 위치에 있던 문서가 몇 번째로 인쇄되는지를 출력

---

## Python vs Java 구현 비교

### 1. 입출력 처리
- **Python**
  ```python
  import sys
  input = sys.stdin.readline  # 간단한 입력 처리
  ```
- **Java**
  ```java
  BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
  BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
  StringBuilder sb = new StringBuilder();  // 효율적인 문자열 처리
  ```

### 2. 자료구조 활용
- **Python**
  - `deque`와 튜플을 사용하여 간단하게 구현
  - `(중요도, 인덱스)` 형태의 튜플로 데이터 관리
  ```python
  queue = deque([(p, idx) for idx, p in enumerate(priorities)])
  ```
- **Java**
  - `ArrayDeque`와 `int[]` 배열 사용
  - 추가로 중요도 카운팅을 위한 배열 필요
  ```java
  Deque<int[]> deque = new ArrayDeque<>();
  int[] priority = new int[10];  // 중요도 카운팅 배열
  ```

### 3. 우선순위 처리 방식
- **Python**
  ```python
  if any(current[0] < q[0] for q in queue):  # 간단한 최대값 확인
  ```
- **Java**
  ```java
  // 중요도 배열을 통한 효율적인 확인
  for(int j = 9; j > current[0]; j--) {
      if(priority[j] > 0) {
          flag = false;
          break;
      }
  }
  ```

### 4. 코드 특징 비교
| 특징 | Python | Java |
|------|---------|------|
| 코드 길이 | 짧고 간결 | 비교적 긴 편 |
| 가독성 | 높음 | 구조적이나 복잡 |
| 실행 속도 | 상대적으로 느림 | 빠름 |
| 메모리 사용 | 효율적 | 약간 더 많이 사용 |
| 구현 난이도 | 쉬움 | 중간 |

### 5. 구현 시 주의사항
1. **Python**
   - `deque`의 `popleft()`와 `append()` 활용
   - `enumerate`로 인덱스 자동 관리
   - 리스트 컴프리헨션으로 간결한 코드 작성

2. **Java**
   - 입출력 버퍼 관리 필요
   - 명시적인 타입 선언 필요
   - 중요도 카운팅 배열 관리 필요
   - `StringBuilder`를 통한 출력 최적화
